// I would prefer this to be save.lua and load it using NSBundle
// But I failed. I don't know why.

static const char * savelua = ""
"-- This script receives four parameters, all encoded with\n"
"-- MessagePack. The decoded values are used for saving a model\n"
"-- instance in Redis, creating or updating a hash as needed and\n"
"-- updating zero or more sets (indices) and zero or more hashes\n"
"-- (unique indices).\n"
"--\n"
"-- # model\n"
"--\n"
"-- Table with one or two attributes:\n"
"--    name (model name)\n"
"--    id (model instance id, optional)\n"
"--\n"
"-- If the id is not provided, it is treated as a new record.\n"
"--\n"
"-- # attrs\n"
"--\n"
"-- Array with attribute/value pairs.\n"
"--\n"
"-- # indices\n"
"--\n"
"-- Fields and values to be indexed. Each key in the indices\n"
"-- table is mapped to an array of values. One index is created\n"
"-- for each field/value pair.\n"
"--\n"
"-- # uniques\n"
"--\n"
"-- Fields and values to be indexed as unique. Unlike indices,\n"
"-- values are not enumerable. If a field/value pair is not unique\n"
"-- (i.e., if there was already a hash entry for that field and\n"
"-- value), an error is returned with the UniqueIndexViolation\n"
"-- message and the field that triggered the error.\n"
"--\n"
"local model   = cmsgpack.unpack(ARGV[1])\n"
"local attrs   = cmsgpack.unpack(ARGV[2])\n"
"local indices = cmsgpack.unpack(ARGV[3])\n"
"local uniques = cmsgpack.unpack(ARGV[4])\n"
"\n"
"local function save(model, attrs)\n"
"	if model.id == nil then\n"
"		model.id = redis.call(\"INCR\", model.name .. \":id\")\n"
"	end\n"
"\n"
"	model.key = model.name .. \":\" .. model.id\n"
"\n"
"	redis.call(\"SADD\", model.name .. \":all\", model.id)\n"
"	redis.call(\"DEL\", model.key)\n"
"\n"
"	if math.mod(#attrs, 2) == 1 then\n"
"		error(\"Wrong number of attribute/value pairs\")\n"
"	end\n"
"\n"
"	if #attrs > 0 then\n"
"		redis.call(\"HMSET\", model.key, unpack(attrs))\n"
"	end\n"
"end\n"
"\n"
"local function index(model, indices)\n"
"	for field, enum in pairs(indices) do\n"
"		for _, val in ipairs(enum) do\n"
"			local key = model.name .. \":indices:\" .. field .. \":\" .. tostring(val)\n"
"\n"
"			redis.call(\"SADD\", model.key .. \":_indices\", key)\n"
"			redis.call(\"SADD\", key, model.id)\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"local function remove_indices(model)\n"
"	local memo = model.key .. \":_indices\"\n"
"	local existing = redis.call(\"SMEMBERS\", memo)\n"
"\n"
"	for _, key in ipairs(existing) do\n"
"		redis.call(\"SREM\", key, model.id)\n"
"		redis.call(\"SREM\", memo, key)\n"
"	end\n"
"end\n"
"\n"
"local function unique(model, uniques)\n"
"	for field, value in pairs(uniques) do\n"
"		local key = model.name .. \":uniques:\" .. field\n"
"\n"
"		redis.call(\"HSET\", model.key .. \":_uniques\", key, value)\n"
"		redis.call(\"HSET\", key, value, model.id)\n"
"	end\n"
"end\n"
"\n"
"local function remove_uniques(model)\n"
"	local memo = model.key .. \":_uniques\"\n"
"\n"
"	for _, key in pairs(redis.call(\"HKEYS\", memo)) do\n"
"		redis.call(\"HDEL\", key, redis.call(\"HGET\", memo, key))\n"
"		redis.call(\"HDEL\", memo, key)\n"
"	end\n"
"end\n"
"\n"
"local function verify(model, uniques)\n"
"	local duplicates = {}\n"
"\n"
"	for field, value in pairs(uniques) do\n"
"		local key = model.name .. \":uniques:\" .. field\n"
"		local id = redis.call(\"HGET\", key, tostring(value))\n"
"\n"
"		if id and id ~= tostring(model.id) then\n"
"			duplicates[#duplicates + 1] = field\n"
"		end\n"
"	end\n"
"\n"
"	return duplicates, #duplicates ~= 0\n"
"end\n"
"\n"
"local duplicates, err = verify(model, uniques)\n"
"\n"
"if err then\n"
"	error(\"UniqueIndexViolation: \" .. duplicates[1])\n"
"end\n"
"\n"
"save(model, attrs)\n"
"\n"
"remove_indices(model)\n"
"index(model, indices)\n"
"\n"
"remove_uniques(model, uniques)\n"
"unique(model, uniques)\n"
"\n"
"return tostring(model.id)\n";
